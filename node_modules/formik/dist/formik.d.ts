/// <reference types="react" />
import * as PropTypes from 'prop-types';
import * as React from 'react';
export interface FormikValues {
    [field: string]: any;
}
export declare type FormikErrors<Values> = {
    [field in keyof Values]?: any;
};
export declare type FormikTouched<Values> = {
    [field in keyof Values]?: boolean & FormikTouched<Values[field]>;
};
export interface FormikState<Values> {
    values: Values;
    error?: any;
    errors: FormikErrors<Values>;
    touched: FormikTouched<Values>;
    isSubmitting: boolean;
    status?: any;
}
export interface FormikComputedProps<Values> {
    readonly dirty: boolean;
    readonly isValid: boolean;
    readonly initialValues: Values;
}
export interface FormikActions<Values> {
    setStatus(status?: any): void;
    setError(e: any): void;
    setErrors(errors: FormikErrors<Values>): void;
    setSubmitting(isSubmitting: boolean): void;
    setTouched(touched: FormikTouched<Values>): void;
    setValues(values: Values): void;
    setFieldValue(field: keyof Values, value: any, shouldValidate?: boolean): void;
    setFieldValue(field: string, value: any, shouldValidate?: boolean): void;
    setFieldError(field: keyof Values, message: string): void;
    setFieldError(field: string, message: string): void;
    setFieldTouched(field: keyof Values, isTouched?: boolean, shouldValidate?: boolean): void;
    setFieldTouched(field: string, isTouched?: boolean, shouldValidate?: boolean): void;
    validateForm(values?: any): void;
    resetForm(nextValues?: any): void;
    submitForm(): void;
    setFormikState<K extends keyof FormikState<Values>>(f: (prevState: Readonly<FormikState<Values>>, props: any) => Pick<FormikState<Values>, K>, callback?: () => any): void;
}
export interface FormikActions<Values> {
    setFieldValue(field: string, value: any): void;
    setFieldError(field: string, message: string): void;
    setFieldTouched(field: string, isTouched?: boolean): void;
    setFormikState<K extends keyof FormikState<Values>>(state: Pick<FormikState<Values>, K>, callback?: () => any): void;
}
export interface FormikHandlers {
    handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
    handleChange: (e: React.ChangeEvent<any>) => void;
    handleBlur: (e: any) => void;
    handleReset: () => void;
}
export interface FormikSharedConfig {
    validateOnChange?: boolean;
    validateOnBlur?: boolean;
    isInitialValid?: boolean | ((props: object) => boolean | undefined);
    enableReinitialize?: boolean;
}
export interface FormikConfig<Values> extends FormikSharedConfig {
    initialValues: Values;
    onReset?: (values: Values, formikActions: FormikActions<Values>) => void;
    onSubmit: (values: Values, formikActions: FormikActions<Values>) => void;
    component?: React.ComponentType<FormikProps<Values>> | React.ReactNode;
    render?: ((props: FormikProps<Values>) => React.ReactNode);
    validationSchema?: any | (() => any);
    validate?: ((values: Values) => void | object | Promise<FormikErrors<Values>>);
    children?: ((props: FormikProps<Values>) => React.ReactNode) | React.ReactNode;
}
export declare type FormikProps<Values> = FormikState<Values> & FormikActions<Values> & FormikHandlers & FormikComputedProps<Values>;
export declare class Formik<ExtraProps = {}, Values = object> extends React.Component<FormikConfig<Values> & ExtraProps, FormikState<any>> {
    static defaultProps: {
        validateOnChange: boolean;
        validateOnBlur: boolean;
        isInitialValid: boolean;
        enableReinitialize: boolean;
    };
    static propTypes: {
        validateOnChange: PropTypes.Requireable<any>;
        validateOnBlur: PropTypes.Requireable<any>;
        isInitialValid: PropTypes.Requireable<any>;
        initialValues: PropTypes.Requireable<any>;
        onReset: PropTypes.Requireable<any>;
        onSubmit: PropTypes.Validator<any>;
        validationSchema: PropTypes.Requireable<any>;
        validate: PropTypes.Requireable<any>;
        component: PropTypes.Requireable<any>;
        render: PropTypes.Requireable<any>;
        children: PropTypes.Requireable<any>;
        enableReinitialize: PropTypes.Requireable<any>;
    };
    static childContextTypes: {
        formik: PropTypes.Requireable<any>;
    };
    initialValues: Values;
    getChildContext(): {
        formik: {
            handleBlur: (e: any) => void;
            handleChange: (e: React.ChangeEvent<any>) => void;
            handleReset: () => void;
            handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
            validateOnChange: (FormikConfig<Values> & ExtraProps)["validateOnChange"];
            validateOnBlur: (FormikConfig<Values> & ExtraProps)["validateOnBlur"];
            dirty: boolean;
            isValid: boolean;
            initialValues: Values;
            setStatus(status?: any): void;
            setError(e: any): void;
            setErrors(errors: FormikErrors<Values>): void;
            setSubmitting(isSubmitting: boolean): void;
            setTouched(touched: FormikTouched<Values>): void;
            setValues(values: Values): void;
            setFieldValue(field: keyof Values, value: any, shouldValidate?: boolean | undefined): void;
            setFieldValue(field: string, value: any, shouldValidate?: boolean | undefined): void;
            setFieldValue(field: string, value: any): void;
            setFieldError(field: keyof Values, message: string): void;
            setFieldError(field: string, message: string): void;
            setFieldError(field: string, message: string): void;
            setFieldTouched(field: keyof Values, isTouched?: boolean | undefined, shouldValidate?: boolean | undefined): void;
            setFieldTouched(field: string, isTouched?: boolean | undefined, shouldValidate?: boolean | undefined): void;
            setFieldTouched(field: string, isTouched?: boolean | undefined): void;
            validateForm(values?: any): void;
            resetForm(nextValues?: any): void;
            submitForm(): void;
            setFormikState<K extends "error" | "values" | "errors" | "touched" | "isSubmitting" | "status">(f: (prevState: Readonly<FormikState<Values>>, props: any) => Pick<FormikState<Values>, K>, callback?: (() => any) | undefined): void;
            setFormikState<K extends "error" | "values" | "errors" | "touched" | "isSubmitting" | "status">(state: Pick<FormikState<Values>, K>, callback?: (() => any) | undefined): void;
            values: any;
            error?: any;
            errors: FormikErrors<any>;
            touched: FormikTouched<any>;
            isSubmitting: boolean;
            status?: any;
        };
    };
    constructor(props: FormikConfig<Values> & ExtraProps);
    componentWillReceiveProps(nextProps: Readonly<FormikConfig<Values> & ExtraProps>): void;
    componentWillMount(): void;
    setErrors: (errors: FormikErrors<Values>) => void;
    setTouched: (touched: FormikTouched<Values>) => void;
    setValues: (values: FormikValues) => void;
    setStatus: (status?: any) => void;
    setError: (error: any) => void;
    setSubmitting: (isSubmitting: boolean) => void;
    runValidationSchema: (values: FormikValues, onSuccess?: Function | undefined) => void;
    runValidations: (values?: FormikValues) => void;
    handleChange: (e: React.ChangeEvent<any>) => void;
    setFieldValue: (field: string, value: any, shouldValidate?: boolean) => void;
    handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
    submitForm: () => void;
    executeSubmit: () => void;
    handleBlur: (e: any) => void;
    setFieldTouched: (field: string, touched?: boolean, shouldValidate?: boolean) => void;
    setFieldError: (field: string, message: string) => void;
    resetForm: (nextValues?: Values | undefined) => void;
    handleReset: () => void;
    setFormikState: (s: any, callback?: (() => void) | undefined) => void;
    getFormikActions: () => FormikActions<Values>;
    getFormikComputedProps: () => {
        dirty: boolean;
        isValid: boolean;
        initialValues: Values;
    };
    getFormikBag: () => {
        handleBlur: (e: any) => void;
        handleChange: (e: React.ChangeEvent<any>) => void;
        handleReset: () => void;
        handleSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
        validateOnChange: (FormikConfig<Values> & ExtraProps)["validateOnChange"];
        validateOnBlur: (FormikConfig<Values> & ExtraProps)["validateOnBlur"];
        dirty: boolean;
        isValid: boolean;
        initialValues: Values;
        setStatus(status?: any): void;
        setError(e: any): void;
        setErrors(errors: FormikErrors<Values>): void;
        setSubmitting(isSubmitting: boolean): void;
        setTouched(touched: FormikTouched<Values>): void;
        setValues(values: Values): void;
        setFieldValue(field: keyof Values, value: any, shouldValidate?: boolean | undefined): void;
        setFieldValue(field: string, value: any, shouldValidate?: boolean | undefined): void;
        setFieldValue(field: string, value: any): void;
        setFieldError(field: keyof Values, message: string): void;
        setFieldError(field: string, message: string): void;
        setFieldError(field: string, message: string): void;
        setFieldTouched(field: keyof Values, isTouched?: boolean | undefined, shouldValidate?: boolean | undefined): void;
        setFieldTouched(field: string, isTouched?: boolean | undefined, shouldValidate?: boolean | undefined): void;
        setFieldTouched(field: string, isTouched?: boolean | undefined): void;
        validateForm(values?: any): void;
        resetForm(nextValues?: any): void;
        submitForm(): void;
        setFormikState<K extends "error" | "values" | "errors" | "touched" | "isSubmitting" | "status">(f: (prevState: Readonly<FormikState<Values>>, props: any) => Pick<FormikState<Values>, K>, callback?: (() => any) | undefined): void;
        setFormikState<K extends "error" | "values" | "errors" | "touched" | "isSubmitting" | "status">(state: Pick<FormikState<Values>, K>, callback?: (() => any) | undefined): void;
        values: any;
        error?: any;
        errors: FormikErrors<any>;
        touched: FormikTouched<any>;
        isSubmitting: boolean;
        status?: any;
    };
    render(): any;
}
export declare function yupToFormErrors<Values>(yupError: any): FormikErrors<Values>;
export declare function validateYupSchema<T>(data: T, schema: any, context?: any): Promise<void>;
export * from './Field';
export * from './Form';
export * from './withFormik';
export * from './FieldArray';
export * from './utils';
